Strings contents:
1. Difference between String and String Buffer
 - Mutability and immutability
 - equals() method
2. String object creation Heap and SCP(String Constant pool)
3. Importance of String constant pool
4. Important FAQ on String and StringBuffer
5. Important constructor of String class
6. Important method of String class
 - 1 chatAt()
 - 2 concat()
 - 3 equals()
 - 4 equalIgnoreCase()
 - 5 isEmpty()
 - 6 length()
 - 7 replace()
 - 8 subString()
 - 9 indexOf()
 - 10 lastIndexOf()
 - 11 toLowerCase()
 - 12 toUpperCase();
 - 13 trim();
7. Important conclusions on String immutability.
8. Creation of our own immutable class
9. final vs immutability
10. Need of StringBuffer
11. String buffer class constructor
12. Important method of String Buffer
 - 1 length()
 - 2 capacity()
 - 3 charAt()
 - 4 reverse()
 - 5 append
 - 6 insert()
 - 7 delete()
 - 8 deleteCharAt()
 - 9 ensureCapacity()
 - 10 trimToSize
13. Need of String Builder
14. StringBuffer vs StringBuilder
15. String vs StringBuffer vs StringBuilder
16. Methods Chaining.

-----------------------------------------------------------------------------------------------------------------------------------------------------

Part 1. Difference between String and String Buffer
Basic difference is String is immutable and StringBuffer is mutable

Immutablity of String:
Once we create a string object we cant perform any chages in the existing object. 
If we are trying to perform  any changes, with those changes new object will be created. 
This non changeble nature is nothing but immutability of the string object.
Example:
    String s = new String("Durga");
    s.concat("Software");
    System.out.println(s); //Will print Durga only. Because its immutable. another orphan object will be created.


Mutability of StringBufffer:
Once we create a StringBuffer object we can perform any type of changes in the existing object. 
This changeble behaviour is nothing but mutability of the StringBuffer object.
Example:
    StringBuffer sb = new StringBuffer("Durga");
    sb.append("Software");
    System.out.println(sb); //Will print Durga Software. Because its mutable.


== vs equals() in case of String and StringBuffer classes.
In String 
    String s1 = new String("Durga");
    String s2 = new String("Durga");
Here,
s1 == s2; false
s1.equals(s2); true 


StringBuffer sb1 = new StringBuffer("Durga");
StringBuffer sb2 = new StringBuffer("Durga");
Here,
s1 == s2; false and
s1.equals(s2); is also false.
.
.
Becasue Object.equals() method is meant for reference comparison.
In String class which inherits Object class equals() method is overriden to compare contents But this is not in case of StringBuffer.
So StringBuffer equals() methods simply checks for reference comparison.
.
.
.
String s1 = new String("Hello");
String s2 = new String("Hello");
System.out.println(s1 == s2); //false. Because s1 and s2 reference or object are seperate in heap.
.
String s3 = "Hello";
String s4 = "Hello";
System.out.println(s3 == s4);//true. Because s3 and s4 are same in String constant pool 
.
String s3 = "Hello Vijay";
String s4 = "Hello " + "Vijay";//This is going to be performed at compile time only. So this will go in SCP area only.
System.out.println(s3 == s4); //True because no seperate object for s4 is created in SCP. Will use s3 only.
.
String s4 = "you cannot change me";
String s6 = "you cannot";
String s7 = s6 + " change me";
System.out.println(s4 == s7);// false. Because this is executed at runtime so the seperate object will be in heap area.
-----------------------------------------------------------------------------------------------------------------------------------------------------

Part2. String object creation Heap and SCP(String Constant pool)

String s = new String("Durga"); vs String s = "Durga";

case1: 
String s = new String("Durga");
- In this case 2 object will be created.
- One in heap area and another in SCP area for further reference.
- If you create another object with same content ie "Durga" then only in heap area new object will be created and in SCP area already created object will be used.

case2:
String s = "Durga";
- In this case only one object created in SCP area for further references.
- If you create another String s1 = "Durga" then it will again use already created "Durga" reference and will not create another one in SCP.
.
.
Example:
String s1 = new String("Durga); 
String s2 = new String("Durga); 
String s3 = "Durga";
String s4 = "Durga";

Heap
for s1 new Object1 "Durga" will be created.
for s2 new Object2 "Durga" will be created.

SCP
for s1 new Object1 "Durga" will be created.
for s2, s3, s4 Object1 "Durga" will be used always.
------------------------
Example2:
String s = new String("Durga");
s.concat("Software");
s = s.concate("Solutions");

Heap
"Durga"
"DurgaSoftware"
"DurgaSolutions"

SCP
"Durga": for first line 
"Software": copy for second line
"Solutions": one copy for third line.

- For "Durga Software nothing will be created in SCP area because SCP area is meant for Constants and not for rutime operation results."


Example3:

String s1 = new String("spring");
s1.concat("fall");
String s2=s1.concat("winter");
s2.concat("Summer");
Sop(s1); // spring
Sop(s2); // SpringWinter


Heap
Spring for s1
SpringFall
SpringWinter
SpringWinterSummer

SCP
spring
fall
winter
summer

Example4
        String s1 = new String("durga");
        String s2 = s1.toUpperCase();
        String s3 = s1.toLowerCase();
        System.out.println(s1==s2);//false: created new object for s1
        System.out.println(s1==s3);//true: no new object created for s3

Example5:
        String s1 = new String("durga");
        String s2 = s1.toString();
        String s3 = s1.toLowerCase();
        String s4 = s1.toUpperCase();
        System.out.println(s1==s2);//true: no new obj created for s2
        System.out.println(s1==s3);//false: no new obj created used existing copy of 'durga' 
        System.out.println(s1==s4);//false: created new copy for s4 for uppercase of 'durga' i.e. DURGA 
-----------------------------------------------------------------------------------------------------------------------------------------------------
Part3: Importance of String constant pool
Advantage 
Same object can be used multiple times instead of creating new object.
Memory saved, performace increased.

Problem:
Any person try to change it then all reference will be affected.
To prevent that java introuced immutability.
So just because of SCP concept immuability is added.
-----------------------------------------------------------------------------------------------------------------------------------------------------
Part4: Important FAQ on String and StringBuffer
Q1. Why scp concept is available only for String object but not for StringBuffer?
Ans:
String is most commonly used object in java so java has provided special memory management for string. 
String buffer is not regularly used so there is not seperate management is done for it.
------------------------
Q2. Why string object are immutable where as StringBuffer object mutable?
Ans: 
- SCP is avaialble for String.  
- With SCP same object can be reused multiple times.
- By using one reference if anyone changes the contents then remaining references are affected.
- If any person tries to change the content with those changes a new object should be created and in the existing object not allowed to change.
- So the immutability concept is there for String.

StringBuffer:
There is no concept of SCP for String buffer.
So no reusability and every time seperate object is required to create.
If I change content from any object then there no impact on other instances.
------------------------
Q3. In addition to string object any other object are immutable in java?
Ans:
All wrapper classes are by default immutable.
Byte, Short, Integer, Long, Float, Double, Character, Boolean
-----------------------------------------------------------------------------------------------------------------------------------------------------
Part 5. Important constructor of String class:

1. String s = new String();
- Creates empty string object in heap area.

2. String s = new String(String literal);
- For the given string literal object is created in heap area.

3. String s = new String(StringBuffer sb);

4. String s = new String(StringBuilder sb);

5. String s = new String(char[] ch);
char[] ch = {'j','a','v','a'}
String s = new String(ch);

6. String s = new String(byte[] b);
byte[] b = {97,98,99,100}
String s = new String(b);
sop(s);// abcd
-----------------------------------------------------------------------------------------------------------------------------------------------------
Part8: Creation of our own immutable class

final class Test {
    private int i;
    Test(int i) {
        this.i = i;
    }
    
    public Test modify(int i) {
        if(this.i == i) {
            return this;
        } else {
            return new Test(i);
        }
    }
    
    public static void main(String[] args){
        Test t1 = new Test(10); //created an object
        Test t2 = t1.modify(100);// created another object holding 100
        Test t3 = t1.modify(10);//t3 will poinintng to first object 10
        
        System.out.println(t1==t2);// false
        System.out.println(t1==t3);// true
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------
Part9. final vs immutability
If you dont want reassignment for variable then it is final.
If you dont want to perofrm any changes in the object then it is immutable.

Immutability is about object not about variable.
final variable: yes
final object: no
immutable variable: no
immutable object: true

-----------------------------------------------------------------------------------------------------------------------------------------------------
