Map
Content:
Content1: 

Map:
Map is not child element of Collection.
If we want to represent group of object as key value pair then we should go for map.
Both keys and values are object obly
Duplicate keys not allowed. Values can be duplicate.
Each key value pair is called Entry.
Hence map is considered as Entry objects.

Map specifice methods:
1. Object put(Object key,Object value);
If you try to put new value with new key it will return null.
If you try to put object with duplicate key it will return object with old value.
2. void putAll(Map m);
3. Object get(Object key);
4. Object remove(Object key);
5. boolean containsKey(Object key);
6. boolean containsValue(Object value);
7. boolean isEmpty();
8. int size();
9. void clear();

Collection views of map:
get only key
Set keySet();
Collection value();
Set entrySet();


Entry Interface:
A Map is a group of key value pair. And each key value pair is called entry.
Hence a map is considered as collection of entries object.
Without existing map object there is no chance of entry object.
Hence entry interface is defined inside map interface.

interface map 
{
	interface Entry 
	{
			Object getKey();
			Object getValue();
			Object setValue();
	}
}

These 3 methods we can only apply on entry object.
----------------------------------------------------------------
HashMap
- Underlying Data structure: HashTable
- Insertion order not preserved and it is based on hashcode of keys.
- Duplicate keys not allowed.
- Duplicate values allowed.
- Heterogeneous object are allowed for keys and values.
- Null is allowed for key but only once.
- Null is allowed for values for any number of times.
- Hashmap implements serializable and clonable but not RandomAccess.
- Hashmap us best choice if it is search operation.

Constructors:
1. HashMap h = new HashMap();// With default initail capacity 16. and Default fill ratio 0.75
2. HashMap m = new HashMap(int initial capacity);
3. HashMap m = new HashMap(int initial capacity, float fillRatio);
4. HashMap m = new HashMap(Map map);


Example:
	public static void main(String[] args) 
	{
		HashMap m = new HashMap();
		m.put("Chiranjivi",700);
		m.put("Balaih",800);		
		m.put("Venkatesh",200);		
		m.put("Nagarjuna",500);
		System.out.println(m);
		Set s = m.keySet();//{Chiranjivi=700, Balaih=800, Venkatesh=200, Nagarjuna=500}
		System.out.println(s);//[Chiranjivi, Balaih, Venkatesh, Nagarjuna]
		
		Iterator itr = s.iterator();
		while(itr.hasNext()) {
			Map.Entry m1 = (Map.Entry)itr.next();
			System.out.println(m1.getKey() + "____" + m1.getValue());
			if(m1.getKey().equals("Nagarjuna")) 
			{
				m1.setValue(100000);
			}
		}
		System.out.println(m);
	}
-----------------------------------------

Difference between hashmap and hashtable

HashMap: Every methods present in Hashmap is not synchronized.
HashTable: Every methods present in HashTable is synchronized.

HashMap: At a time multiple threads are allowed to operate on hashmap object. So not threadsafe.
HashTable: At a time multiple threads are allowed to operate on HasTable. So it is thread safe.

HashMap: To operate on hashmap threads are not required to wait. So performance is high.
HashTable:To operate on hashtable threads are required to wait. So performance is low.

HashMap: Null keys and values are allowed in hashmap.
HashTable: Null key or null value is not allowed in HashTable.

HashMap: 1.2. Not legacy.
HashTable: 1.0 version. Legacy



How to get synchronized version of hashmap object?
By default hashmap is non-synchronized but we can get synchronized version of hashmap by using synchronizedMap method of Collections class.
HashMap m = new HashMap();
Map m1 = Collection.synchronizedMap(m); //m is non-synchronized where m1 is synchronized.

----------------------------------------------------------------------------------
HashMap vs LinkedHashMap
- Child class of hashmap.
- Exactly same as hashmap including methodsa and constructors Except following differences.

UnderlyingDataStructure
HashMap: HashTable
LinkedHashMap: LinkedList + HashTable(Hybrid data structure)

Insertion order
HashMap: Insertion order is not preserved and it is based on hashcode of keys.
LinkedHashMap: Insertion order is preserved.

Version
HashMap: Introduced in 1.2
LinkedHashMap: Introduced in 1.4 

LinkedHashSet and LinkedHashMap commonly used for developing cache based applications.



Difference between == and .equals methods
In general == operator meant for reference comparison or address comparison.
Where as .equals method meant for content comparison.

Integer I1 = new Integer(10);
Integer I2 = new Integer(10);
sop(I1 == I2); //false
sop(I1.equals(I2)); true
-----------------------------------

IdentityHashMap
HashMap m = new HashMap();
Integer I1 = new Integer(10);
Integer I2 = new Integer(10);

m.put(I1, "Pawan");
m.put(I2, "Kalyan");
SOP(m); //{10 = Kalyan}
.
In case of HashMap JVM will use .equals() method to check duplicate keys.
Example:
		HashMap m = new HashMap();
		Integer I1 = new Integer(10);
		Integer I2 = new Integer(10);
		m.put(I1,"Pawan");
		m.put(I2,"Kalyan");
		System.out.println(m);//{10=Kalyan}. 10 Pawan will be replaced with 10 Kalyan. Because HashMap Uses .equals method to check duplicate keys.

If you want == to check duplicate then go for IdentityHashMap.

Example:
		IdentityHashMap m = new IdentityHashMap();
		Integer I1 = new Integer(10);
		Integer I2 = new Integer(10);
		m.put(I1,"Pawan");
		m.put(I2,"Kalyan");
		
		System.out.println(m);
		//{10=Pawan, 10=Kalyan}. Here 10, 10 are equal but not same.
		//Here IdentityHashMap used == to check duplicates,

IdentityHashMap:
It is exactly same as HashMap including methods and constructors Except the following difference.
In the case of normal hashmap JVM will use .equals() method to idenify duplicate keys, wihch is meant for content comparison.
But in the case of identity hashmap JVM will ise == operator to idenify duplicate keys, which is meant for reference(address) comparison.
	
-----------------------------------
WeakHashMap:

We tried to null the object which is used as key with HashMap and WeakHashMap.
HashMap: 
import java.util.*;
class MapDemo 
{
	public static void main(String[] args) 
	{
		HashMap m = new HashMap();
		Temp t = new Temp();
		m.put(t,"Durga");
		System.out.println(m);
		t = null;
		System.gc();
		try {
			Thread.sleep(5000);			
		} catch (Exception e) {
			
		}
		System.out.println(m);
	}
}

class Temp 
{
	public String toString() {
		return "temp";
	}
	
	public void finalize() {
		System.out.println("Finalize method called!!");
	}
	
}

output
{temp=Durga}
{temp=Durga}


With WeakHashMap
import java.util.*;
class MapDemo 
{
	public static void main(String[] args) 
	{
		WeakHashMap m = new WeakHashMap();
		Temp t = new Temp();
		m.put(t,"Durga");
		System.out.println(m);
		t = null;
		System.gc();
		try {
			Thread.sleep(5000);			
		} catch (Exception e) {
			
		}
		System.out.println(m);
	}
}

class Temp 
{
	public String toString() {
		return "temp";
	}
	
	public void finalize() {
		System.out.println("Finalize method called!!");
	}
	
}

output of program:
{temp=Durga}
Finalize method called!!
{}

-----------------------------------------------------------------------

HashMap vs WeakHashMap:
WeakHashMap: It is exactly same as HashMap except below

In case of HashMap object doesnt have any reference it is not eligible for gc.
If it is associated with HashMap ie. HashMap dominates Garbage collector.

But in the case of weak hashmap, if oject doesnt contain any references it is eligible for gc.
Even though object is associated with the WeakHashMap ie. 
Garbage collector dominates weak hashmap.

In above example temp object is not eligible for gc because it is associated wiht hashmap in this case output is 
{temp=Durga}
{temp=Durga}


In the above program if we replace HashMap with WeakHashMap then 
temp object is eligible for gc. In this case output is:

{temp=Durga}
Finalize method called!!
{}

-----------------------------------------------------------------------------------
Sorted Map
Child interface of mpa
If we want to represent group of key values pair accoording to some sorting order of keys then we should go for sorted map.
Sorted is based on the key but not based on values.

Sorted map defines following specific methods:
1. Object firstKey(); //101
2. Object lastKey()//136
3. SortedMap headMap(Object key);//107: {101=A, 103=B, 104=C}
4. SortedMap tailMap(Object key);//107: 107=D, 125=E, 136=F
5. SortedMap subMap(Object key1, Object key2); // {103=B, 104=C, 107=D}
6. Comparator comparator() //null

Example:
101 - A
103 - B
104 - C
107 - D
125 - E
136 - F


TreeMap:
- UnderlyingDataStructure: RED-BLACK Tree
- Insertion order: Not preserved and it is based on some sorting order of keys
- Duplicate keys not allowed but value can be duplicate.
- If we are depending on default natural sorting order then keys should be homogeneous and comparable otherwise runtime exception
ClassCasteException
If we are defining our own sorting by comparator then keys need not be homogeneous and comparable.
We can heterogeneous non comparable objects also.
Whether we are depending on default natural sorting orede or cusomized sorting order there are no restrictions for values.
We can take heterogeneous non comparable objects also..
Null Acceptance: 
For non empty treemop if we are trying to insert entry with null key then we will get NPE.
For empty treemap as a forst entry with null keyis allowed. But after that if we are trying to enter eny entry then we will get NPE.


The above null acceptance rule until 1.6 version.. after that null is not allowed for key.
But for values we can use null any numer of times there is not restriction whether it is 1.6 or 1.7 version.


constructors 4:
TreeMap t = new TreeMap()
Creates empty tree map with Default Natural sorting order.

TreeMap t = new TreeMap(Comparator c)
For cusomized sorting order.
TreeMap t = new TreeMap(SortedMap m)
TreeMap t = new TreeMap(Map m)

Example for DEfault natural sorting order:
	public static void main(String[] args) 
	{
		TreeMap m = new TreeMap();
		m.put(100,"ZZZ");
		m.put(103,"YYY");
		m.put(101,"XXX");
		m.put(104,106);		
		//m.put("FFF","XXX");//CCE
		//m.put(null,"XXX");//NPE
	    System.out.println(m);
	}

output:{100=ZZZ, 101=XXX, 103=YYY, 104=106}

Example with customized sorting 
import java.util.*;
class MapDemo 
{
	public static void main(String[] args) 
	{
		TreeMap m = new TreeMap(new MyComparator());
		m.put("XXX",10);
		m.put("AAA",20);
		m.put("ZZZ",30);
		m.put("LLL",40);		
	    System.out.println(m);
	}
}

class MyComparator implements Comparator 
{
	public int compare(Object obj1, Object obj2)
	{
		String s1 = obj1.toString();
		String s2 = obj2.toString();
		return s1.compareTo(s2);//{AAA=20, LLL=40, XXX=10, ZZZ=30}		
		return s1.compareTo(s2);//{ZZZ=30, XXX=10, LLL=40, AAA=20}

	}
}

--------------------
HashMap
LinkedHashMap
IndentityHashMap
WeakHashMap
TreeMap

































-----------------------------------------------------------------------













