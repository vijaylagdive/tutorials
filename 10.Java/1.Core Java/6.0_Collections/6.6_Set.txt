Set Contents:
1. Set
2. HashSet
3. Constructor of HashSet
4. LinkedHashSet
5. SortedSet
6. SortedSet Specific methods:
7. TreeSet
8. TreeSet construtors: 4
9. Diffrence between Set implemented classes.
---------------------------------------------------------------------------------------------------
1. Set Interface:
- It is the Child interface of Collection interface.
- Use cases: We can use Set when we want to represent a group of individual objects as a single entity,
in which duplicates are not allowed and insertion order not preserved.
- Set is implemented by class Hashset,LinkedHashSet and TresSet which implements SortedSet. 
- Set interface doesnt contain any new methods. So we have to use only Collection methods.
Note: In collection heteregeneous objects are not allowed only in TreeSet, TreeMap
Because in this objects are stored in some sorting order.
To arrange objects in sorting orders compulsory we need to compare two objects.
For the comparison purpose objects must be homogeneous.
---------------------------------------------------------------------------------------------------
2. Hashset Class:
- Underlying data structure: HashTable.
- Duplicates are not allowed. 
- Insertion order is not preserved.
- 'null' insertion is possible.
- Heterogeneous objects are allowed.
- Implements serializable and clonable interfaces but not RandomAccess.
- Use Case: HashSet is the best choice, if our frequent operation is Search operation.

Notes:
- If we try to insert duplicates, we wont get any compile time or runtime errors,
  but the add() method simply will return false.
- Insertion order is not preserved and all objects will be inserted based on hashcode of objects.
-------------------------------------------------
3. Constructor of HashSet
1. HashSet h = new HashSet();
- Will create empty hasSet object with default initial capacity of 16 and default fill ratio 0.75.

2. HashSet h = new HashSet(int initialCapacity);
- Creates an empty HashSet object with specified initial capacity & default Fill ration 0.75 of that initial capacity.

3. HashSet h = new HashSet(int initialCapacity, float loadFactor);
- Creates an empty HashSet object with specified initial capacity and specified loadFactor or fill ratio.

4. HashSet h = new HashSet(Collection c);
For inter conversion between Collection object.

Notes:
Example:
	public static void main(String[] args) {
		HashSet h = new HashSet();
		h.add("B");
		h.add("C");
		h.add("D");		
		h.add("Z");
		h.add(null);
		System.out.println(h.add("Z"));//false. Will not add duplicate. Return false.
		System.out.println(h);//[null, B, C, D, Z]. Insertion order is not preserved.
	}
---------------------------------------------------------------------------------------------------
4. LinkedHashSet:
- Underlying data structure: HashTable + LinkedList
- Duplicates are not allowed.
- But insertion order preserved.
- Use Case:LinkedHashSet is the best choice, if our frequent operation is Search operation.
- Note: LinkedHashSet is the best choice to develop cache based applications, where duplicate are not allowed
and insertion order must be preserved.

Example:
	public static void main(String[] args) {
		LinkedHashSet h = new LinkedHashSet();
		h.add("B");
		h.add("C");
		h.add("D");		
		h.add("Z");
		h.add(null);
		System.out.println(h.add("Z"));//false. Will not add duplicate. Return false.
		System.out.println(h);//[B, C, D, Z, null]. Insertion order is preserved.
	}
	
---------------------------------------------------------------------------------------------------
5. SortedSet(I)
It is the child interface of set.
We can use it when:
Duplicates should not be allowed some sorting order is needed.
-------------------------------------------------
6. SortedSet Specific methods:
1. Object first(); 
- Return first element of the sortedSet.

2. Object last(); 
- Returns last element of the SortedSet

3. SortedSet headSet(Object obj); 
- Return the sortedSet whose element are < obj

4. SortedSet tailSet(Object obj); 
Return sortedSet whose element are >=obj

5. SortedSet subSet(Object obj1, Object obj2);
- Returns the SortedSet whose element are >= obj1 and <obj2

6. Comparator comparator();
- Return Comparator object that describes underlying sorting technique.
- If we are using default natural sorting order then we will get null.

Example: {100,101,103,104,107,110,115} 
1. first();// 100
2. last(); //115
3. headSet(104);// 100,101,103
4. tailSet(104);// 104,107,110,115
5. subSet(103,110);// 103,104,107
6. comparator() null

Note:
1. Default natural sorting order for numners ascending order and for sorting alphabetical order.
2. We can apply the aboce methods only on SortedSet implemented class object. That is on the TreeSet object.
-------------------------------------------------------------------------------------------------------------------
7. TreeSet:
- The underlying data structure: Balanced Tree.
- Duplicates objects are not allowed.
- Insertion order is not preserved, but all object will be inserted according to some sorting order.
- Heterogeneous object are not allowed. If we try to insert Heterogeneous object then we will get runtime exception saying ClassCasteException.
- Null insertion is allowed but only once.
- For empty TreeSet as the first element null insertion is possible.
- But after inserting that null if we are trying to insert any another element we will get  NullPoiniterException.
-------------------------------------------------
8. TreeSet construtors: 4
1. TreeSet t = new TreeSet();
- Creates an empty TreeSet object where elements will be instered according to Default Natural Sorting Order.

2. TreeSet t = new TreeSet(Comparator c);
Creates an empty TreeSet object where elements will be inserted according to customizing sorting order.

3. TreeSet t = new TreeSet(Collection c);

4. TreeSet t = new TreeSet(SortedSet s);

Example:
	public static void main(String[] args) {
		TreeSet t = new TreeSet();
		t.add("A");
		t.add("a");
		t.add("B");		
		t.add("Z");
		t.add("L");
		System.out.println(t);//[A, B, L, Z, a]. Insertion is according to natural alphabetical sorting order.
	}


Example of TreeSet with StringBuffer:
Example:
	public static void main(String[] args) {
		TreeSet t = new TreeSet();
		t.add(new StringBuffer("A"));
		t.add(new StringBuffer("Z"));
		t.add(new StringBuffer("L"));
		t.add(new StringBuffer("B"));
		System.out.println(t); //Class Caste Exception
	}

Note:
1. If we are depending on default natural sorting order then objects should be homogeneous and comparable.
Otherwise we will get runtime exception saying ClassCasteException.
2. An object is said to be comparable if and only if the corresponding class implements java.lang.comparable interface.
3. String and all wrapper classes already implements comparable interface. But StringBuffer doesn't implements comparable interface.
Hence in the above program we get ClassCasteException.

Special note:
Since from jdk-11 StringBuffer and StringBuilder also implements Comparable
-----------------------------------------------------------------
9. Diffrence between Set implemented classes.

1. Underlying data structure.
HashSet: HashTable
LinkedHashSet: HashTable + LinkedList
TreeSet: Balanced Tree

2. Insertion order 
HashSet: Not Preserved
LinkedHashSet: Preserved
TreeSet: Not applicable

3. Sorting order 
HashSet: Not Applicatble
LinkedHashSet: Not Applicatble
TreeSet: Applicable

4. Heterogeneous Objects
HashSet: Allowed
LinkedHashSet: Allowed
TreeSet: Not Allowed*

5. Duplicates
HashSet: Not allowed
LinkedHashSet: Not allowed 
TreeSet: Not allowed

Null acceptance
HashSet: Allowed once
LinkedHashSet: Allowed once
TreeSet: For empty treeset as first element Null is allowed and in all other cases we will get NPE. 
-----------------------------------------------------------------






































