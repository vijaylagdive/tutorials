https://academind.com/tutorials/understanding-rxjs

Q1. What is RxJS?
Ans 1. Full form is Reactive Extension for Java Script.
2. It is a library used for composing asynchronous and callback-based code in a functional, reactive style using Observables. 
Many APIs such as HttpClient produce and consume RxJS Observables and also uses operators for processing observables.

For example, you can import observables and operators for using HttpClient as below,
import { Observable, throwError } from 'rxjs';
import { catchError, retry } from 'rxjs/operators';

installing rxJS?
npm install --save rxjs@6
-------------------------------------------------

Q2. What is Observable?
1. Observable is a feature in a RxJS library which provides supports for passing message between publishers and subscribers in application.
2. They are mainly used for event handling, asynchronous programming, and handling multiple values. 
In this case, you define a function for publishing values, but it is not executed until a consumer subscribes to it. 
The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.

in RxJS specifically, an observable is a sequence of values that can be observed over time, similar to an event stream. 
An observable in RxJS represents a data stream that can emit multiple values over time. It can emit regular data, error messages, or a completion signal. Observables are used to handle events, handle asynchronous data like HTTP requests, timers, user interactions, and more.


3. In angular Observable are used to:
a) To communicate between components
b) To handle AJAX request and response.
c) The router and form modules use Observable to listen for and to respond to user-input events.

4. We manuallly can use observable to pass messages between components etc.
-------------------------------------------------
Q3. Implement observable.

ngOnInit(): void {
  const customObs = new Observable(observer => {
      let count = 0;
      setInterval(() => {
        count++;
        if (count <= 3) {
          observer.next(count);
        } else if (count === 4) {
          observer.complete();
        } else {
          observer.error('Error: count is greater than 3!');          
        }
      },1000);
  });

  customObs.subscribe(data => {
    console.log(data);
  }, error => {
    console.log(error);
  }, () => {
    console.log('completed');
  });
}

When error thrown observable is cancelled.
-------------------------------------------------

Q4. What are the operators in Observable?
Ans: 1.Operators are functions build on the observable foundation that you can use to 
manipulate observable output into new observable.
2. map(), filter(), pipe() etc

e.g.
  customObs.pipe(
  filter((data => {return data > 1;})),
  map((data : number) => {return 'Round : '+ data;}))
 .subscribe(data => {
    console.log(data);
  }, error => {
    console.log(error);
  }, () => {
    console.log('completed');
  });
-------------------------------------------------
Q5. Difference between Observable and Promises?
Ans:
1. 
Promise emits single value
Observable emits multiple values.

2. 
Promises are not lazy
If we comment .then() of the promise, still the api call will be placed.

Observable are Lazy. 
Observables are not called until we subscribe to the Observable.
If we comment code which is subscribing to the Promise then the api call will not be done.

3. 
Promise cannot be cancelled
Observable can be cancelled by using the unsubscribe method.

4. 
Promise doesnt have any operator.
Observable provides many operator like map, forEach, filter, reduce, retry etc

-------------------------------------------------
Q6. Difference between Observable and Subect?
Ans:
Observable
An Observable is unicast. An Observer and its Subscriber have a one-to-one relationship. 
Each subscribed Observer owns an independent execution of the Observable.

Subject
In comparison to a regular Observable, a Subject allows values to be multicasted to many Observers. 
A Subject and its subscribers have a one-to-many relationship.

-------------------------------------------------
Q7. Subjects and behaviour subjects?
Ans: 
Observable:
Unicast means can emit values from the observable not from any other component.
Subject:
multicast, can cast values to multiple subscribers and can act as both subscribers and emmitter
vs
The BehaviourSubject is a variant of the Subject. 
This variant knows about the current value, which a normal Subject doesn't.
--------------------------------------------------
Q8. Observer methods
next() to emit value
error() 
complete() to know our observable you are done.
--------------------------------------------------
Q9. concatMap
Used when there are 1000 records but we want fetch one by one.

userArr : Array<string> = ['1', '2', '3', '4', '5'];
  from(this.userArr).pipe(
    concatMap(u => this.http.get(`https://reqres.in/api/users/${u}`))).subscribe(
    data => {
      console.log(data);
    }
  );
--------------------------------------------------
Q10. mergeMap
https://levelup.gitconnected.com/handle-multiple-api-requests-in-angular-using-mergemap-and-forkjoin-to-avoid-nested-subscriptions-a20fb5040d0c

Ans:
We can use mergeMap when we need data from the first API request to make requests to the second API.
example: 
  this.http.get(`https://reqres.in/api/users`).pipe(
    map(data => {
      return data['data'][0];
    }),
    mergeMap((user) => 
        this.http.get(`https://reqres.in/api/users/${user.id}`)
      ))
    .subscribe(data => {
      console.log('Dataa: ',data);
    }
  );
---------------------------------------------------------------------------------------------------
Q11. switchmap

Switchmap used when there are multiple apis are called and user want to get result of the latest api and previous apis 
to be cancelled.

Switchmap has cancellable effect.

Used to search list based on user input entered into the input field.
When user enters one key first api will be called, when user enters another key second api will be called cancelling the first one.

example:
 userArr : Array<string> = ['1', '2', '3', '4', '5'];
  from(this.userArr).pipe(
    switchMap(u =>         
        this.http.get(`https://reqres.in/api/users/${u}`)
      )).subscribe(
    data => {
      console.log('data: ',data);
    }
  );

---------------------------------------------------------------------------------------------------

Q12. forkjoin
Ans:
This operator is best used when you have a group of observables and only care about the final emitted value of each. 
It means that forkJoin allows us to group multiple observables and execute them in parallel, then return only one observable.

When do we apply forkJoin?
We use it when API requests are independent. 
It means that they do not depend on each other to complete and can execute in parallel.

example:
  const user1 = this.http.get(`https://reqres.in/api/users/1`);
  const user2 = this.http.get(`https://reqres.in/api/users/2`)

  forkJoin([user1,user2]).subscribe(data => {
    console.log('Data 0',data[0]);
    console.log('Data 1',data[1]);
  });
---------------------------------------------------------------------------------------------------

Q13. Merging mergeMap and the forkJoin
Ans:
  this.http.get(`https://reqres.in/api/users`).pipe(
    map(data => {
      return data['data'][0];
    }),
    mergeMap((user) => {
        console.log(user);
        const user1 = this.http.get(`https://reqres.in/api/users/1`);
        const user2 = this.http.get(`https://reqres.in/api/users/1`);
        return forkJoin([user1, user2]);
      }
    ))
    .subscribe(data => {
      console.log('Dataaa: ',data);
    }
  );
---------------------------------------------------------------------------------------------------
Q14. pipe operator.
- The pipe operator allows you to chain multiple operations or transformations on an observable sequence.

- The pipe operator provides a way to apply a series of operators to the observable, allowing you to transform, 
filter, combine, and perform various other operations on the data emitted by the observable.

- Unlike map, which is an operator, pipe is a method on Observable which is used for composing operators. 
pipe was introduced to RxJS in v5.5 to take code that looked like this:

of(1,2,3).map(x => x + 1).filter(x => x > 2);
and turn it into this
.
to
.
of(1,2,3).pipe(
  map(x => x + 1),
  filter(x => x > 2)
);

----------------------------------------------------------------------------------------------------
